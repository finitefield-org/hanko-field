package catalog

import (
    "fmt"
    "path"
    "strconv"
    "strings"

	templpkg "github.com/a-h/templ"

	"finitefield.org/hanko-admin/internal/admin/templates/components"
	"finitefield.org/hanko-admin/internal/admin/templates/helpers"
	"finitefield.org/hanko-admin/internal/admin/templates/layouts"
)

const modalInputClass = "w-full rounded-lg border border-slate-300 px-3 py-2 text-sm text-slate-700 shadow-sm focus:border-brand-500 focus:outline-none focus:ring-2 focus:ring-brand-200"

templ UpsertModal(data ModalFormData) {
	@layouts.Modal(data.Title, upsertModalBody(data))
}

templ upsertModalBody(data ModalFormData) {
	<form
		class="space-y-6 text-sm text-slate-700"
		hx-target="#modal"
		hx-swap="innerHTML"
		{ modalMethodAttrs(data.Method, data.ActionURL)... }
	>
		for _, hidden := range data.HiddenFields {
			<input type="hidden" name={ hidden.Name } value={ hidden.Value } />
		}
		if data.Description != "" {
			<p class="text-sm text-slate-600">{ data.Description }</p>
		}
		if data.Error != "" {
			<div class="rounded-lg border border-rose-200 bg-rose-50 px-3 py-2 text-sm text-rose-700">{ data.Error }</div>
		}
		for _, section := range data.Sections {
			@catalogFormSection(section)
		}
		<div class="flex flex-col gap-2 pt-2">
			<button type="submit" class={ helpers.ButtonClass(modalTone(data.SubmitTone), "md", true, false) }>{ data.SubmitLabel }</button>
			<p class="text-xs text-slate-500">送信後に一覧が自動更新されます。</p>
		</div>
	</form>
}

templ catalogFormSection(section ModalSectionData) {
	<section class="space-y-4 rounded-2xl border border-slate-200 bg-white/80 p-4 shadow-xs">
		<div>
			<p class="text-xs font-semibold uppercase tracking-wide text-slate-500">{ section.Title }</p>
			if section.Description != "" {
				<p class="text-xs text-slate-500">{ section.Description }</p>
			}
		</div>
		<div class="grid gap-4 md:grid-cols-2">
			for _, field := range section.Fields {
				<div class={ fieldContainerClass(field.FullWidth) }>
					@catalogFormField(field)
				</div>
			}
		</div>
	</section>
}

templ catalogFormField(field ModalFieldData) {
	<label class="flex flex-col gap-1 text-sm text-slate-600">
		<span class="text-xs font-semibold uppercase tracking-wide text-slate-500">
			{ field.Label }
			if field.Required {
				<span class="ml-1 text-rose-500">*</span>
			}
		</span>
		@catalogInputField(field)
	</label>
	if field.Hint != "" {
		<p class="text-xs text-slate-500">{ field.Hint }</p>
	}
	if field.Error != "" {
		<p class="text-xs text-rose-600">{ field.Error }</p>
	}
}

templ catalogInputField(field ModalFieldData) {
	if field.Prefix != "" || field.Suffix != "" {
		<div class="flex items-center gap-2">
			if field.Prefix != "" {
				<span class="text-xs text-slate-500">{ field.Prefix }</span>
			}
			@catalogInputControl(field)
			if field.Suffix != "" {
				<span class="text-xs text-slate-500">{ field.Suffix }</span>
			}
		</div>
		return
	}
	@catalogInputControl(field)
}

templ catalogInputControl(field ModalFieldData) {
	switch field.Type {
	case "textarea":
		<textarea
			name={ field.Name }
			class={ modalInputClass }
			rows={ textareaRows(field.Rows) }
			placeholder={ field.Placeholder }
			required?={ field.Required }
			if field.Autocomplete != "" {
				autocomplete={ field.Autocomplete }
			}
			if field.InputMode != "" {
				inputmode={ field.InputMode }
			}
		>{ field.Value }</textarea>
	case "select":
		<select
			name={ field.Name }
			class={ modalInputClass }
			required?={ field.Required }
		>
			if !field.Required {
				<option value="">選択してください</option>
			}
			for _, option := range field.Options {
				<option value={ option.Value } selected?={ option.Selected }>{ option.Label }</option>
			}
		</select>
	case "asset":
		@catalogAssetUpload(field)
	default:
		<input
			name={ field.Name }
			class={ modalInputClass }
			type={ inputType(field.Type) }
			value={ field.Value }
			placeholder={ field.Placeholder }
			required?={ field.Required }
			if field.Autocomplete != "" {
				autocomplete={ field.Autocomplete }
			}
			if field.InputMode != "" {
				inputmode={ field.InputMode }
			}
		/>
	}
}

templ catalogAssetUpload(field ModalFieldData) {
	{{ asset := field.Asset }}
	if asset == nil {
		<div class="rounded border border-rose-200 bg-rose-50 px-3 py-2 text-xs text-rose-600">アップロード設定が見つかりません。</div>
		return
	}
	{{ hasAsset := assetHasValue(asset) }}
	<div
		class="space-y-3"
		data-asset-upload
		data-has-value={ boolString(hasAsset) }
		data-label-empty={ asset.EmptyLabel }
		data-label-upload={ asset.UploadLabel }
		data-label-replace={ asset.ReplaceLabel }
		data-label-remove={ asset.RemoveLabel }
		data-upload-endpoint={ helpers.BasePath(ctx) + "/assets/signed-upload" }
		if asset.Purpose != "" {
			data-purpose={ asset.Purpose }
		}
		if asset.Kind != "" {
			data-kind={ asset.Kind }
		}
		if asset.Accept != "" {
			data-accept={ asset.Accept }
		}
		if asset.MaxSizeBytes > 0 {
			data-max-size={ strconv.FormatInt(asset.MaxSizeBytes, 10) }
		}
		data-preview-enabled={ boolString(asset.DisplayPreview) }
	>
		<input type="hidden" name={ asset.AssetIDName } value={ asset.AssetID } data-asset-upload-field="id" />
		<input type="hidden" name={ field.Name } value={ asset.URLFieldValue } data-asset-upload-field="url" />
		if asset.FileNameName != "" {
			<input type="hidden" name={ asset.FileNameName } value={ asset.FileName } data-asset-upload-field="name" />
		}
		<div class="flex items-start gap-4">
			<div class={ assetPreviewClass(asset.DisplayPreview, hasAsset) } data-asset-upload-preview>
				if asset.DisplayPreview {
					if hasAsset && asset.AssetURL != "" {
						<img src={ asset.AssetURL } alt={ coalesceLabel(field.Label, "プレビュー") } class="h-full w-full rounded-lg object-cover" />
					} else {
						<div class="flex h-full w-full items-center justify-center text-[11px] text-slate-400">{ asset.EmptyLabel }</div>
					}
				} else {
					<div class="flex h-full w-full items-center justify-center text-[11px] text-slate-500" data-asset-upload-placeholder>{ assetFileLabel(asset, hasAsset) }</div>
				}
			</div>
			<div class="flex flex-1 flex-col gap-2">
				<div class="flex flex-wrap items-center gap-2">
					<button type="button" class={ helpers.ButtonClass("secondary", "sm", false, false) } data-asset-upload-action="select">{ assetTriggerLabel(asset, hasAsset) }</button>
					<button type="button" class={ helpers.ButtonClass("ghost", "sm", false, false) } data-asset-upload-action="remove" hidden?={ !hasAsset }>{ asset.RemoveLabel }</button>
				</div>
				<input type="file" class="hidden" accept={ asset.Accept } data-asset-upload-input />
				<p class="text-xs text-slate-500" data-asset-upload-filename>{ assetFileLabel(asset, hasAsset) }</p>
				if asset.MaxSizeBytes > 0 {
					<p class="text-[11px] text-slate-400">最大 { formatFileSize(asset.MaxSizeBytes) }</p>
				}
			</div>
		</div>
	</div>
}

templ DeleteModal(data DeleteModalData) {
	@layouts.Modal(data.Title, deleteModalBody(data))
}

templ deleteModalBody(data DeleteModalData) {
	<form
		class="space-y-6 text-sm text-slate-700"
		hx-target="#modal"
		hx-swap="innerHTML"
		{ modalMethodAttrs(data.Method, data.ActionURL)... }
	>
		for _, hidden := range data.HiddenFields {
			<input type="hidden" name={ hidden.Name } value={ hidden.Value } />
		}
		<p class="text-sm text-slate-600">{ data.Description }</p>
		<div class="rounded-xl border border-slate-200 bg-white px-3 py-2">
			<p class="text-xs text-slate-500">{ data.KindLabel } · { data.ItemIdentifier }</p>
			<p class="text-base font-semibold text-slate-900">{ data.ItemName }</p>
		</div>
		if len(data.Metadata) > 0 {
			<div class="grid gap-2 rounded-xl border border-slate-100 bg-slate-50/80 p-3 text-sm text-slate-600">
				for _, meta := range data.Metadata {
					<div class="flex items-center justify-between gap-2">
						<span class="text-xs text-slate-500">{ meta.Key }</span>
						<span class="font-medium text-slate-900">{ meta.Value }</span>
					</div>
				}
			</div>
		}
		if len(data.Dependencies) > 0 {
			<div class="space-y-2 rounded-xl border border-amber-200 bg-amber-50 p-3">
				<p class="text-xs font-semibold uppercase tracking-wide text-amber-700">依存関係</p>
				for _, dep := range data.Dependencies {
					<div class="flex items-center justify-between text-sm">
						<span>{ dep.Label }</span>
						@components.Badge(dep.Status, dep.Tone)
					</div>
				}
			</div>
		}
		<div class="rounded-xl border border-rose-200 bg-rose-50 px-3 py-2 text-sm text-rose-700">
			{ coalesceWarning(data.Warning) }
		</div>
		if data.Error != "" {
			<div class="rounded-md border border-rose-200 bg-white px-3 py-2 text-sm text-rose-700">{ data.Error }</div>
		}
		<div class="flex flex-col gap-3 pt-2">
			<button type="submit" class={ helpers.ButtonClass(modalTone(data.SubmitTone), "md", true, false) }>{ data.SubmitLabel }</button>
			<button type="button" class={ helpers.ButtonClass("ghost", "md", true, false) } data-modal-close>キャンセル</button>
		</div>
	</form>
}

func modalMethodAttrs(method string, action string) templpkg.Attributes {
	switch strings.ToUpper(strings.TrimSpace(method)) {
	case "PUT":
		return templpkg.Attributes{"hx-put": action}
	case "DELETE":
		return templpkg.Attributes{"hx-delete": action}
	default:
		return templpkg.Attributes{"hx-post": action}
	}
}

func assetHasValue(asset *ModalAssetField) bool {
	if asset == nil {
		return false
	}
	if strings.TrimSpace(asset.AssetID) != "" {
		return true
	}
	if strings.TrimSpace(asset.URLFieldValue) != "" {
		return true
	}
	if strings.TrimSpace(asset.AssetURL) != "" {
		return true
	}
	return false
}

func boolString(value bool) string {
	if value {
		return "true"
	}
	return "false"
}

func assetPreviewClass(displayPreview bool, hasAsset bool) string {
	classes := []string{"relative flex h-20 w-20 items-center justify-center overflow-hidden rounded-lg border border-slate-200 bg-slate-50 text-slate-400"}
	if !hasAsset {
		classes = append(classes, "border-dashed")
	} else {
		classes = append(classes, "border-solid")
	}
	if displayPreview {
		classes = append(classes, "bg-white")
	}
	return helpers.ClassList(classes...)
}

func coalesceLabel(values ...string) string {
	for _, value := range values {
		if trimmed := strings.TrimSpace(value); trimmed != "" {
			return trimmed
		}
	}
	return ""
}

func assetFileLabel(asset *ModalAssetField, hasAsset bool) string {
	if asset == nil {
		return ""
	}
	if hasAsset {
		if name := strings.TrimSpace(asset.FileName); name != "" {
			return name
		}
		if url := strings.TrimSpace(asset.AssetURL); url != "" {
			return path.Base(url)
		}
		if id := strings.TrimSpace(asset.AssetID); id != "" {
			return id
		}
	}
	return coalesceLabel(asset.EmptyLabel, "未設定")
}

func assetTriggerLabel(asset *ModalAssetField, hasAsset bool) string {
	if asset == nil {
		return "アップロード"
	}
	if hasAsset {
		return coalesceLabel(asset.ReplaceLabel, asset.UploadLabel, "ファイルを変更")
	}
	return coalesceLabel(asset.UploadLabel, "ファイルをアップロード")
}

func formatFileSize(size int64) string {
	if size <= 0 {
		return ""
	}
	const (
		kilobyte = 1024
		megabyte = 1024 * kilobyte
	)
	if size >= megabyte {
		return fmt.Sprintf("%.1f MB", float64(size)/float64(megabyte))
	}
	if size >= kilobyte {
		return fmt.Sprintf("%.0f KB", float64(size)/float64(kilobyte))
	}
	return fmt.Sprintf("%d B", size)
}

func fieldContainerClass(full bool) string {
	if full {
		return "md:col-span-2"
	}
	return ""
}

func textareaRows(rows int) int {
	if rows <= 0 {
		return 3
	}
	return rows
}

func inputType(value string) string {
	switch strings.ToLower(strings.TrimSpace(value)) {
	case "number":
		return "number"
	case "email":
		return "email"
	case "url":
		return "url"
	default:
		return "text"
	}
}

func modalTone(value string) string {
	if strings.TrimSpace(value) == "" {
		return "primary"
	}
	return strings.TrimSpace(value)
}

func coalesceWarning(value string) string {
	if strings.TrimSpace(value) == "" {
		return "この操作は取り消せません。関連するテンプレートや商品に影響する可能性があります。"
	}
	return value
}
